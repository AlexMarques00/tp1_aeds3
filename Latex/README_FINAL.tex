\documentclass[12pt,a4paper]{article}

% Pacotes fundamentais modernos
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[brazil]{babel}
\usepackage{newtxtext,newtxmath} % Times moderno e matemática
\usepackage[top=3cm, bottom=2cm, left=3cm, right=2cm]{geometry}

% Pacotes para layout e formatação
\usepackage{setspace}
\usepackage{indentfirst}
\usepackage{microtype} 
\usepackage{needspace}
\usepackage{titlesec}
\usepackage{tocloft}

% Pacotes para elementos flutuantes
\usepackage{float}
\usepackage{caption}
\usepackage{booktabs}
\usepackage{array}

% Pacotes para código e cores
\usepackage{listings}
\usepackage{xcolor}

% Pacotes para listas
\usepackage{enumitem}

% Pacotes para links
\usepackage{hyperref}

% Configuração de código Java
\lstdefinestyle{javastyle}{
    language=Java,
    basicstyle=\ttfamily\small,
    keywordstyle=\color{blue!80}\bfseries,
    commentstyle=\color{green!60}\itshape,
    stringstyle=\color{red!70},
    numberstyle=\tiny\color{gray},
    numbers=left,
    numbersep=5pt,
    backgroundcolor=\color{gray!5},
    showstringspaces=false,
    tabsize=4,
    breaklines=true,
    frame=single,
    rulecolor=\color{gray!30},
    aboveskip=1em,
    belowskip=1em
}

% Configuração de títulos ABNT
\titleformat{\section}{\large\bfseries\uppercase}{\thesection}{1em}{}
\titleformat{\subsection}{\large\bfseries}{\thesubsection}{1em}{}
\titleformat{\subsubsection}{\normalsize\bfseries}{\thesubsubsection}{1em}{}

% Espaçamento dos títulos (melhorado para mais respiração visual)
\titlespacing*{\section}{0pt}{2.5em}{1.5em}     % Mais espaço antes e depois das seções
\titlespacing*{\subsection}{0pt}{1.5em}{1em}    % Mais espaço para subseções
\titlespacing*{\subsubsection}{0pt}{1em}{0.5em} % Espaço para sub-subseções

% Configuração automática de quebras
\let\oldsection\section
\let\oldsubsection\subsection
\renewcommand{\section}[1]{\needspace{4\baselineskip}\oldsection{#1}}
\renewcommand{\subsection}[1]{\needspace{3\baselineskip}\oldsubsection{#1}}

% Layout ABNT simplificado
\onehalfspacing
\setlength{\parindent}{1.5cm}
\setlength{\parskip}{0.3em}
\raggedbottom

% Configuração de listas
\setlist[itemize]{leftmargin=2em, itemsep=0.2em, topsep=0.5em}
\setlist[enumerate]{leftmargin=2em, itemsep=0.2em, topsep=0.5em}

% Configuração de tabelas
\renewcommand{\arraystretch}{1.3}
\captionsetup{font=small, labelfont=bf, justification=centering}

% Controle de quebras (simplificado)
\clubpenalty=10000
\widowpenalty=10000

% Configuração de sumário
\renewcommand{\contentsname}{\large\bfseries SUMÁRIO}
\renewcommand{\cftsecleader}{\cftdotfill{\cftdotsep}}
\setlength{\cftbeforesecskip}{0.3em}

\begin{document}

\begin{titlepage}
    \begin{center}
        \vspace*{2cm}
        
        \Huge
        \textbf{Sistema de Gerenciamento de Base de Dados de Animes}
        
        \vspace{0.5cm}
        \LARGE
        Estruturas de Dados, Compressão e Criptografia
        
        \vspace{1.5cm}
        
        \textbf{Trabalhos Práticos I, II, III e IV}\\
        \textbf{Algoritmos e Estruturas de Dados III}
        
        \vspace{1.5cm}
        
        \textbf{Autores:}\\
        \large
        Júlia de Mello\\
        Alex Marques
        
        \vfill
        
        \vspace{0.8cm}
        
        \Large
        Pontifícia Universidade Católica de Minas Gerais\\
        Curso de Engenharia de Computação\\
        
        \vspace{1cm}
        
        \today
        
    \end{center}
\end{titlepage}

\tableofcontents
\thispagestyle{empty}
\newpage

\section{Resumo}

Este relatório documenta o desenvolvimento de um sistema completo de gerenciamento de dados de animes, implementado ao longo de quatro trabalhos práticos da disciplina de Algoritmos e Estruturas de Dados III. O sistema evolui desde uma implementação básica com operações CRUD até um sistema robusto com múltiplos tipos de índices, algoritmos de compressão e técnicas de criptografia. O projeto demonstra a aplicação prática de estruturas de dados avançadas como Árvore B+, Hash Extensível e Lista Invertida, além de algoritmos de compressão (Huffman e LZW), casamento de padrões (Boyer-Moore e KMP) e criptografia (Vigenère e RSA). Os resultados mostram significativa melhoria na eficiência das operações de busca e considerável redução no tamanho dos arquivos através da compressão, enquanto a criptografia garante a segurança dos dados armazenados.

\section{Introdução}

O gerenciamento eficiente de grandes volumes de dados é um desafio fundamental na ciência da computação. Este projeto implementa um sistema completo para gerenciamento de uma base de dados de animes, explorando diversas técnicas e estruturas de dados para otimizar operações de armazenamento, busca, compressão e segurança.

O desenvolvimento foi dividido em quatro etapas incrementais:
\begin{itemize}
    \item \textbf{TP1}: Implementação básica com CRUD e ordenação externa
    \item \textbf{TP2}: Adição de estruturas de indexação (Árvore B+, Hash Extensível, Lista Invertida)
    \item \textbf{TP3}: Implementação de compressão (Huffman, LZW) e casamento de padrões (Boyer-Moore, KMP)
    \item \textbf{TP4}: Adição de técnicas de criptografia (Vigenère, RSA)
\end{itemize}

O sistema utiliza Java como linguagem de implementação, manipulando arquivos binários para armazenamento persistente e oferecendo uma interface de linha de comando para interação com o usuário.

\section{Desenvolvimento}
\vspace{1em}
\subsection{TP1 - Fundamentos e Operações Básicas}

\subsubsection{Estrutura do Arquivo Principal}

O arquivo binário principal (\texttt{animeDataBase.db}) foi projetado com a seguinte estrutura:

\begin{itemize}
    \item \textbf{Cabeçalho}: 4 bytes contendo o número total de registros (18.495)
    \item \textbf{Registros}: Cada registro contém:
    \begin{itemize}
        \item Lápide (2 bytes): Marca se o registro está ativo (' ') ou excluído ('*')
        \item Tamanho (2 bytes): Tamanho do registro em bytes
        \item Dados serializados: Objeto Anime convertido em bytes
    \end{itemize}
\end{itemize}

\subsubsection{Classe Animes}

A classe principal representa um anime com os seguintes atributos:
\begin{itemize}
    \item \texttt{id}: Identificador único
    \item \texttt{name}: Nome do anime
    \item \texttt{type}: Tipo de mídia (5 bytes fixos)
    \item \texttt{episodes}: Número de episódios
    \item \texttt{rating}: Nota do anime
    \item \texttt{year}: Data de lançamento (classe MyDate)
    \item \texttt{genres}: Lista de gêneros
    \item \texttt{season}: Temporada de lançamento
    \item \texttt{studio}: Estúdio responsável
\end{itemize}

\subsubsection{Operações CRUD}

Implementou-se as quatro operações básicas:
\begin{itemize}
    \item \textbf{Create}: Inserção de novos registros no final do arquivo
    \item \textbf{Read}: Busca sequencial por ID
    \item \textbf{Update}: Atualização in-place quando possível, realocação caso contrário
    \item \textbf{Delete}: Exclusão lógica marcando a lápide
\end{itemize}

\subsubsection{Ordenação Externa}

Foi implementada uma classe de ordenação externa para organizar o arquivo após modificações. O algoritmo utiliza:
\begin{itemize}
    \item \textbf{Distribuição}: Divisão do arquivo em sessões menores
    \item \textbf{Ordenação interna}: Algoritmo de seleção para cada sessão
    \item \textbf{Intercalação}: Merge das sessões ordenadas
\end{itemize}

\textbf{Nota}: Esta classe foi posteriormente descontinuada com a implementação dos índices no TP2, pois a indexação tornou desnecessária a manutenção de ordem física dos registros.

\subsection{TP2 - Estruturas de Indexação}

A adição de índices revolucionou a eficiência do sistema, eliminando a necessidade de busca sequencial e ordenação externa.

\subsubsection{Árvore B+}

Implementada para indexação primária por ID:

\begin{itemize}
    \item \textbf{Estrutura}: Árvore balanceada com dados apenas nas folhas
    \item \textbf{Ordem configurável}: Definida pelo usuário na inicialização
    \item \textbf{Operações}: Inserção, busca e impressão da estrutura
    \item \textbf{Complexidade}: O(log n) para todas as operações
\end{itemize}

A classe \texttt{Pagina} representa os nós da árvore, armazenando elementos, offsets e ponteiros para filhos.

\subsubsection{Hash Extensível}

Implementado para acesso direto por ID:

\begin{itemize}
    \item \textbf{Diretório}: Array de ponteiros para buckets
    \item \textbf{Profundidade global}: Controla o tamanho do diretório
    \item \textbf{Buckets}: Armazenam os registros com profundidade local
    \item \textbf{Expansão dinâmica}: Duplicação do diretório quando necessário
\end{itemize}

A função hash utilizada garante distribuição uniforme:
\begin{lstlisting}[style=javastyle]
protected int hash(int chave) {
    int hash = chave;
    hash = (hash ^ (hash >>> 16)) & 0x7fffffff;
    return hash % (int) Math.pow(2, profundidadeGlobal);
}
\end{lstlisting}

\subsubsection{Lista Invertida}

Implementada para buscas por atributos secundários:

\begin{itemize}
    \item \textbf{Dicionário}: Mapeia termos para endereços de blocos
    \item \textbf{Blocos}: Contêm listas de offsets dos registros
    \item \textbf{Atributos indexados}: Temporada, episódios, estúdio, nota, gêneros
    \item \textbf{Buscas combinadas}: Interseção de múltiplos critérios
\end{itemize}

\subsection{TP3 - Compressão e Casamento de Padrões}

\subsubsection{Algoritmos de Compressão}

\textbf{Huffman:}
\begin{itemize}
    \item \textbf{Princípio}: Codificação baseada na frequência dos caracteres
    \item \textbf{Implementação}: Construção da árvore de Huffman e geração de códigos
    \item \textbf{Vantagem}: Eficiente para dados com distribuição desigual de frequências
    \item \textbf{Escolha}: Ideal para textos onde alguns caracteres são muito mais frequentes
\end{itemize}

\textbf{LZW (Lempel-Ziv-Welch):}
\begin{itemize}
    \item \textbf{Princípio}: Substituição de sequências repetidas por códigos
    \item \textbf{Dicionário dinâmico}: Construído durante a compressão
    \item \textbf{Vantagem}: Eficiente para dados com padrões repetitivos
    \item \textbf{Escolha}: Ideal para dados estruturados como bancos de dados
\end{itemize}

\subsubsection{Algoritmos de Casamento de Padrões}

\textbf{Boyer-Moore:}
\begin{itemize}
    \item \textbf{Estratégia}: Busca da direita para a esquerda com saltos inteligentes
    \item \textbf{Pré-processamento}: Tabela de caracteres ruins
    \item \textbf{Complexidade}: O(nm) no pior caso, O(n/m) no melhor caso
    \item \textbf{Escolha}: Eficiente para padrões longos e alfabetos grandes
\end{itemize}

\textbf{KMP (Knuth-Morris-Pratt):}
\begin{itemize}
    \item \textbf{Estratégia}: Evita comparações desnecessárias usando informações anteriores
    \item \textbf{Pré-processamento}: Tabela de falhas (failure function)
    \item \textbf{Complexidade}: O(n+m) garantido
    \item \textbf{Escolha}: Complexidade linear garantida, ideal para buscas frequentes
\end{itemize}

\subsection{TP4 - Criptografia e Segurança}

\subsubsection{Cifra de Vigenère}

Implementação de criptografia simétrica:
\begin{itemize}
    \item \textbf{Chave}: String alfabética fornecida pelo usuário
    \item \textbf{Operação}: Deslocamento cíclico baseado na chave
    \item \textbf{Aplicação}: Byte a byte em todo o arquivo
    \item \textbf{Escolha}: Simplicidade de implementação e velocidade
\end{itemize}

\begin{lstlisting}[style=javastyle]
public byte[] criptografar(byte[] dados) {
    byte[] resultado = new byte[dados.length];
    int chaveIndex = 0;
    
    for (int i = 0; i < dados.length; i++) {
        int dadoByte = dados[i] & 0xFF;
        char chaveChar = chave.charAt(chaveIndex % chave.length());
        int chaveValor = chaveChar - 'A';
        int criptografado = (dadoByte + chaveValor) % 256;
        resultado[i] = (byte) criptografado;
        chaveIndex++;
    }
    return resultado;
}
\end{lstlisting}

\subsubsection{RSA}

Implementação de criptografia assimétrica:
\begin{itemize}
    \item \textbf{Geração de chaves}: Números primos de 512 bits
    \item \textbf{Chaves numéricas}: Uso exclusivo de BigInteger
    \item \textbf{Processamento em blocos}: Devido às limitações do RSA
    \item \textbf{Escolha}: Segurança robusta com chaves públicas/privadas
\end{itemize}

\textbf{Problema Crítico Resolvido:}
Um bug significativo foi identificado onde \texttt{BigInteger.\\toByteArray()} remove zeros à esquerda, corrompendo dados como o cabeçalho do arquivo. A solução implementada preserva o tamanho original:

\begin{lstlisting}[style=javastyle]
// Durante criptografia: salva tamanho original
baos.write(bloco.length); // Tamanho original
baos.write((blocosCriptografados.length >> 8) & 0xFF);
baos.write(blocosCriptografados.length & 0xFF);
baos.write(blocosCriptografados);

// Durante descriptografia: restaura tamanho
if (blocosDescriptografados.length < tamanhoOriginal) {
    byte[] blocosCompletos = new byte[tamanhoOriginal];
    System.arraycopy(blocosDescriptografados, 0, 
                   blocosCompletos, tamanhoOriginal - blocosDescriptografados.length, 
                   blocosDescriptografados.length);
    baos.write(blocosCompletos);
}
\end{lstlisting}

\subsubsection{Integração com CRUD}

O sistema de criptografia foi integrado ao CRUD através de:
\begin{itemize}
    \item \textbf{Arquivos temporários}: Descriptografia automática para operação
    \item \textbf{Detecção automática}: Identificação do tipo de criptografia pelo nome do arquivo
    \item \textbf{Sincronização}: Garantia de uso da mesma instância RSA
    \item \textbf{Limpeza automática}: Remoção de arquivos temporários órfãos
\end{itemize}

\newpage % Nova página para seção de testes
\needspace{3cm}
\section{Testes e Resultados}

\subsection{Desempenho dos Índices}

\begin{table}[H]
\centering
\begin{tabular}{@{}lcccc@{}}
\toprule
\textbf{Operação} & \textbf{Sequencial} & \textbf{Árvore B+} & \textbf{Hash Extensível} & \textbf{Lista Invertida} \\
\midrule
Busca por ID & O(n) & O(log n) & O(1) & N/A \\
Busca por atributo & O(n) & N/A & N/A & O(k) \\
Inserção & O(1) & O(log n) & O(1) amort. & O(k) \\
Espaço & O(n) & O(n) & O(n) & O(n·m) \\
\bottomrule
\end{tabular}
\caption{Complexidade das operações por tipo de índice}
\end{table}

\subsection{Eficiência da Compressão}

Testes realizados com o arquivo \texttt{animeDataBase.db} contendo dados reais de animes:

\begin{table}[H]
\centering
\begin{tabular}{@{}lccc@{}}
\toprule
\textbf{Algoritmo} & \textbf{Tamanho Original} & \textbf{Tamanho Comprimido} & \textbf{Taxa de Compressão} \\
\midrule
Huffman & 3.032 bytes & 2.026 bytes & 33,18\% \\
LZW & 3.032 bytes & 1.542 bytes & 49,17\% \\
\bottomrule
\end{tabular}
\caption{Resultados reais de compressão obtidos nos testes}
\end{table}

\textbf{Análise dos Resultados:}
\begin{itemize}
    \item O algoritmo \textbf{LZW} apresentou melhor taxa de compressão (49,17\%), sendo mais eficiente para este tipo de dados estruturados
    \item O algoritmo \textbf{Huffman} obteve taxa de 33,18\%, ainda assim significativa para redução de espaço
    \item Ambos os algoritmos demonstraram eficácia na compressão de dados textuais e estruturados
    \item O LZW é particularmente eficiente em dados com padrões repetitivos, como campos estruturados de animes
\end{itemize}

\textbf{Tempos de Execução dos Algoritmos de Compressão:}

\begin{table}[H]
\centering
\begin{tabular}{@{}lccc@{}}
\toprule
\textbf{Algoritmo} & \textbf{Tempo Compressão} & \textbf{Tempo Descompressão} & \textbf{Eficiência} \\
\midrule
Huffman & 97 ms & 57 ms & Rápido \\
LZW & 7.841 ms & 78 ms & Lento na compressão \\
\bottomrule
\end{tabular}
\caption{Tempos de execução reais dos algoritmos de compressão}
\end{table}

\textbf{Observações sobre Performance:}
\begin{itemize}
    \item \textbf{Huffman}: Mais rápido na compressão (97ms vs 7.841ms), ideal para aplicações em tempo real
    \item \textbf{LZW}: Apesar de mais lento na compressão, oferece melhor taxa de redução
    \item \textbf{Descompressão}: Ambos apresentam tempos similares e aceitáveis (57-78ms)
    \item \textbf{Trade-off}: Huffman para velocidade, LZW para máxima compressão
\end{itemize}

\subsection{Casamento de Padrões}

Testes de busca em strings de nomes de animes:

\begin{table}[H]
\centering
\begin{tabular}{@{}lccc@{}}
\toprule
\textbf{Algoritmo} & \textbf{Padrão Curto} & \textbf{Padrão Médio} & \textbf{Padrão Longo} \\
\midrule
Boyer-Moore & Excelente & Bom & Regular \\
KMP & Bom & Bom & Bom \\
Força Bruta & Regular & Ruim & Ruim \\
\bottomrule
\end{tabular}
\caption{Desempenho relativo dos algoritmos de casamento}
\end{table}

\subsection{Segurança e Performance}

\begin{table}[H]
\centering
\begin{tabular}{@{}lccc@{}}
\toprule
\textbf{Algoritmo} & \textbf{Velocidade} & \textbf{Segurança} & \textbf{Complexidade} \\
\midrule
Vigenère & Muito Rápida & Baixa & Simples \\
RSA & Lenta & Alta & Complexa \\
\bottomrule
\end{tabular}
\caption{Comparação dos algoritmos de criptografia}
\end{table}

\subsection{Justificativas das Escolhas}

\textbf{Estruturas de Dados:}
\begin{itemize}
    \item \textbf{Árvore B+}: Escolhida por manter dados ordenados e garantir acesso logarítmico
    \item \textbf{Hash Extensível}: Selecionado para acesso em tempo constante com expansão dinâmica
    \item \textbf{Lista Invertida}: Necessária para indexação de atributos não-chave
\end{itemize}

\textbf{Algoritmos de Compressão:}
\begin{itemize}
    \item \textbf{Huffman}: Eficiente para dados textuais com distribuição não-uniforme
    \item \textbf{LZW}: Superior para dados estruturados com repetições
\end{itemize}

\textbf{Algoritmos de Busca:}
\begin{itemize}
    \item \textbf{Boyer-Moore}: Rápido para padrões longos em alfabetos grandes
    \item \textbf{KMP}: Complexidade linear garantida, confiável
\end{itemize}

\textbf{Algoritmos de Criptografia:}
\begin{itemize}
    \item \textbf{Vigenère}: Demonstração de criptografia simétrica clássica
    \item \textbf{RSA}: Exemplo de criptografia assimétrica moderna
\end{itemize}

\newpage % Nova página para conclusão
\section{Conclusão}

O desenvolvimento deste sistema demonstrou a evolução natural de um projeto de software, partindo de uma implementação básica até um sistema robusto e completo. Cada trabalho prático introduziu conceitos fundamentais que se complementaram para formar uma solução integrada.

\textbf{Principais conquistas:}
\begin{itemize}
    \item Implementação bem-sucedida de estruturas de dados clássicas
    \item Melhoria dramática na eficiência através da indexação (de O(n) para O(1) e O(log n))
    \item Redução efetiva do espaço de armazenamento via compressão (até 49,17\% com LZW)
    \item Garantia de segurança dos dados através de criptografia robusta
    \item Sistema modular permitindo uso independente de cada funcionalidade
\end{itemize}

\textbf{Desafios superados:}
\begin{itemize}
    \item Gerenciamento complexo de múltiplos arquivos binários
    \item Sincronização entre índices durante operações de modificação
    \item Integração transparente da criptografia sem impactar performance
    \item Correção de bugs sutis na implementação RSA (preservação de zeros à esquerda)
    \item Tratamento de casos especiais em estruturas dinâmicas (duplicação de diretório)
\end{itemize}

\textbf{Lições aprendidas:}
\begin{itemize}
    \item A importância da escolha adequada de estruturas de dados para cada tipo de operação
    \item O impacto transformador da indexação na performance de sistemas de dados
    \item A necessidade de testes extensivos para identificar bugs em cenários específicos
    \item A importância da modularidade para facilitar manutenção e extensões futuras
    \item O valor da documentação clara para compreensão e manutenção do código
\end{itemize}

\textbf{Impacto educacional:}
Este projeto proporcionou experiência prática com:
\begin{itemize}
    \item Manipulação de arquivos binários em baixo nível
    \item Implementação de estruturas de dados avançadas
    \item Algoritmos clássicos de ciência da computação
    \item Técnicas de otimização e análise de performance
    \item Integração de sistemas complexos
\end{itemize}

O sistema final representa uma solução completa para gerenciamento de dados, incorporando técnicas modernas de armazenamento, indexação, compressão e segurança. A experiência obtida no desenvolvimento deste projeto fornece uma base sólida para enfrentar desafios similares em projetos futuros de maior escala e complexidade.
Em conclusão, este projeto demonstrou com sucesso a aplicação prática de conceitos fundamentais de estruturas de dados e algoritmos, resultando em um sistema funcional e educativo que serve como excelente base para desenvolvimentos futuros mais complexos.

\end{document}
